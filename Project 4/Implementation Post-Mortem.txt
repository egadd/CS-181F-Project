Post-Mortem Author: Eli Gadd
Team Members: Michael Vassilevsky, Chet Weger
CS 181F
16 December 2012


Project 4: Implementation Post-Mortem


Implementation of Component
The largest restriction on this part of the project was the fact that Michael and Chet’s work was dependent on the models implemented by Eli. Because of this, much of the progress was held up as Eli struggled to understand how the Django models would fit into the components that require them, which was necessary for them to be fully implemented.
This brings out perhaps a deeper issue with our work on this final project: Django is does not require a deep understanding, but a broad one, with many small details to be learned and understood. For the three of us, who were all new to web development as a concept, we struggled to to gain the informational foundation required to actually begin producing working code. We believe that this was a fundamental issue tied to our choice to work with web development despite our complete lack of prior experience. We were under the impression from the beginning of the class that little work would be done with the actual language, so a near complete understanding would not be required. As we progressed into the third and fourth projects, we found that this was not true, and that our lack of understanding of the Django approach to web development and management hindered our ability to produce specifications and designs that would help us later on. As such, our work on this project, would should have been a rather simple process of turning previously created designs into implemented code and then putting the pieces together, turned into a long struggle to redesign with a more complete understanding of Django.
Some other smaller issues plagued us, such as not choosing to create the groupTable model, which was technically supposed to be linked to from the user profile page. As such, code for both the models component and the user profile component have commented out code ready to be used should a functional groupTable be provided. Also, the Django framework does not allow for the name of a project to be changed, so we were stuck with a name chosen from the prototyping section of a previous project.
Not all about this process was difficult. We found the Django tutorials extremely helpful; they implemented a somewhat relatable product that we were able to learn a lot from. Also, Django overall was easy to write code for once the understanding was there. Being Python, there is little complexity, and Django provides plenty of functions and libraries for all of the necessary operations. This allowed for easy coding once the developers understood the language.


Implementation of Test Plan
As a first issue, Eli did not write a test suite for his component. Time became an issue, and the process of understanding how to write test suites for Django models would require more time than was available, so this deliverable is unfortunately missing from the project submission.
This also links to an overall issue with the testing process: Django, because it is so simple, does not clearly come prepared for the implementation of large scale test suites. While they can be implemented, the process is involved and mostly unrewarding because Django is so inherently simple. As such, little was learned from the test suites produced by Chet and Michael. By the time the tests were implemented and run, the developers had struggled with the understanding enough that there was little room for error, and most possible test cases in Django are simple sanity checks. The framework abstracts out so much of the web development work, leaving only the bare minimum to the developers to produce, that testing as a process has a very low benefit to cost ratio.


Development Processes
Eli participated in a code review session. This was helpful because, as previously mentioned, Eli’s work was necessary for the other two to begin work. Thus, Eli could write the code ahead of time on his own, send it to the team to be reviewed (and also for them to begin working with the dummy code) and then finalize it later in the process. Overall, this proved valuable, but still hindered the process somewhat because it required Eli to have a functional understanding of what the components required of his models. This should have been taken care of during the design process, but upon reaching implementation, some issues of design were found to be under or over-specified, leading to more work and research.
        As one might guess from the analysis of the testing process, test driven development proved cumbersome at best as a process for Django development. The majority of the work to be on the implementation was on the understanding of the framework. Once the understanding was present, the actual coding was trivial. Forcing the use of tests along with the coding only took the simple part of the project and injected a new level of difficulty and frustration, slowing down work on the component implementation as a whole. Further, since the tests proved to be so ineffective anyway, the rewards for this process were hard to notice, and hardly outweighed the cost in time and effort. Chet was tasked with using test driven development.
        Pair programming was the most efficient and most effective of the processes chosen. Since, as has been said multiple times previously, understanding how Django represented a website was the key issue of this project, having two heads working together proved to be far more helpful than any individual process. Chet and Michael used this process for Michael’s component, and therefore his component was the most simple to produce.


Integration of The Components
Integration of the models into the two web page components was simple overall. Some tweaks were required as a more complete understanding the model, view, template process was had, but these were trivial to make, and were communicated to Eli as needed. These models were essential in allowing the other two components to proceed, so it was helpful that this integration process went smoothly.
However, combining Michael’s and Chet’s components into one coherent series of web pages proved far more difficult. When this process began, it became clear that the original designs and specifications for the two components had been lacking in how they would fit together. Many hours of tweaking of URLs and other small fixes were required before the two fit together nicely. This was mostly due to the fact that during the design process, we thought we understood how the views and templates would work and integrate, but we eventually learned that this understanding had been lacking.


Preparation of the Release Review/Demo
Almost all of the work required for this falls under the process of integration, described above. That and time constraints were the only issues had, the latter of which will be discussed later.


The Project as an Educational Exercise
We thought that this project, in some ways, extended beyond the educational goals of this class. Given that we had chosen a framework we were unfamiliar with, with little warning against this during the beginning of the class, we became bogged down later on with our lack of familiarity with the process. Countless hours were spent in an effort to learn and understand this framework enough to design and implement code using it. Overall, we felt that this part of the project consumed more time than intended, and that most of the learning value associated with it was lost because so much effort and frustration was involved with the learning and understanding, which lies most definitely outside of the goals of the class, as stated by the professor.
For such a simple language, and ultimately a simple series of components, we felt that the process required by this project also weighed on the educational value and taught us little about these processes. For example, as discussed previously, test driven development was not useful in the development of Django, but per the project requirements, we were forced to in some way make it work for the project.